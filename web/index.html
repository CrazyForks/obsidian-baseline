<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Style Settings Migration Tool for Baseline</title>
    <link rel="stylesheet" href="styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-38V3HD97K9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-38V3HD97K9");
    </script>
  </head>
  <body>
    <div class="title-container">
      <h1>Style Settings Migration Tool for Baseline</h1>
      <a href="https://github.com/aaaaalexis/obsidian-baseline">View Baseline on GitHub</a>
    </div>
    <div class="setting-container">
      <div class="setting">
        <div class="setting-sidebar">
          <div class="sidebar-section">
            <div class="sidebar-title">Community plugins</div>
            <div class="sidebar-link">Minimal Theme Settings</div>
            <div class="sidebar-link is-active">Style Settings</div>
          </div>
        </div>
        <div class="setting-content">
          <div class="setting-header">
            <div class="setting-search">
              <i data-lucide="search"></i>
              Search Style Settings...
            </div>
            <div class="setting-actions">
              <button>Import</button>
              <button>Export</button>
            </div>
          </div>
          <div class="setting-list">
            <div class="setting-item">
              <i data-lucide="chevron-right"></i>
              <div class="setting-item-name">Minimal</div>
              <div class="setting-item-actions"><i data-lucide="rotate-ccw"></i><i data-lucide="cloud-download"></i></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="panels-container">
      <p>Export your existing Minimal style settings, then paste here to migrate to Baseline-compatible settings.</p>

      <div class="input-panel">
        <textarea
          class="prefs-input"
          placeholder='{
  "minimal-style@@bg1@@light": "#FFFFFF",
  "minimal-style@@tabs-style": "tabs-modern"
}'
        ></textarea>
        <div class="panel-actions">
          <button class="clear-btn">Clear</button>
        </div>
      </div>
      <div class="output-panel">
        <textarea class="prefs-output" disabled readonly></textarea>
        <div class="panel-actions">
          <button class="copy-btn">Copy to Clipboard</button>
          <a class="download-link" href="#" download="baseline-style-settings.json"><button class="download-btn">Download</button></a>
        </div>
        <div class="unsupported-container"></div>
      </div>
    </div>

    <script>
      // --- Concise Baseline Migration Script ---
      const $ = (s) => document.querySelector(s);
      const prefsInput = $(".prefs-input"),
        newPrefsOutput = $(".prefs-output"),
        copyBtn = $(".copy-btn"),
        downloadLink = $(".download-link"),
        unsupportedItemsDiv = $(".unsupported-container"),
        clearBtn = $(".clear-btn");

      let mappingCache;

      const getMapping = () =>
        mappingCache
          ? Promise.resolve(mappingCache)
          : fetch("mapping.json")
              .then((r) => (r.ok ? r.json() : Promise.reject(`Status: ${r.status}`)))
              .then((d) => (mappingCache = d));

      // Multi-theme migration logic
      const migratePrefs = (mapping, oldPrefs) => {
        const newPrefs = {},
          unsupported = [];
        // Find all theme base names and their readable names
        const themeBases = {};
        for (const themeKey in mapping) {
          if (mapping[themeKey] && mapping[themeKey].__name) {
            themeBases[themeKey] = mapping[themeKey].__name;
          }
        }
        for (const k in oldPrefs) {
          if (!Object.hasOwnProperty.call(oldPrefs, k)) continue;
          const seg = k.split("@@");
          if (seg.length < 2) continue;
          // Detect theme base (e.g. minimal-style, things-style, sanctum-style, etc.)
          const base = seg[0];
          // Find theme key (e.g. minimal, things, sanctum)
          let themeKey = null;
          for (const t in themeBases) {
            if (base.startsWith(t)) {
              themeKey = t;
              break;
            }
          }
          if (!themeKey) continue;
          const newBase = base.replace(new RegExp(`^${themeKey}`), "baseline");
          const oldId = seg[1],
            extra = seg.slice(2),
            themeMapping = mapping[themeKey],
            rule = themeMapping[oldId],
            val = oldPrefs[k];
          if (!rule) {
            newPrefs[[newBase, oldId, ...extra].join("@@")] = val;
            continue;
          }
          if (rule.unsupported) {
            unsupported.push({
              name: rule.name || `Key '${oldId}'`,
              category: rule.category || "General",
              oldValue: val,
              theme: themeKey,
            });
            continue;
          }
          let newVal = val,
            newKey = rule.newId || oldId;
          if (rule.valueMapping) {
            const vRule = rule.valueMapping[val];
            if (vRule === undefined) {
              unsupported.push({
                name: `Value '${val}' for setting '${oldId}'`,
                category: rule.category || "Unsupported Options",
                theme: themeKey,
              });
              continue;
            }
            if (vRule.unsupported) {
              unsupported.push({
                name: vRule.name || `Option '${val}'`,
                category: vRule.category || "General",
                theme: themeKey,
              });
              continue;
            }
            newVal = vRule;
          }
          newPrefs[[newBase, newKey, ...extra].join("@@")] = newVal;
        }
        return { newPrefs, unsupportedItems: unsupported, themeBases };
      };

      const showResults = (prefs, unsupported, themeBases) => {
        const str = Object.keys(prefs).length ? JSON.stringify(prefs, null, 2) : "";
        newPrefsOutput.value = str;
        downloadLink.href = "data:text/json;charset=utf-8," + encodeURIComponent(str);
        if (unsupported.length) {
          let html = "<h2>Unsupported style settings</h2>";
          // Group by theme, then by category
          const groupedByTheme = {};
          unsupported.forEach((i) => {
            const theme = i.theme || "unknown";
            if (!groupedByTheme[theme]) groupedByTheme[theme] = [];
            groupedByTheme[theme].push(i);
          });
          for (const theme in groupedByTheme) {
            const readable = (themeBases && themeBases[theme]) || theme;
            html += `<div class="unsupported-theme"><div class="unsupported-theme-name">${readable}</div>`;
            // Group by category within theme
            const grouped = groupedByTheme[theme].reduce((a, i) => ((a[i.category] = a[i.category] || []).push(i), a), {});
            for (const cat in grouped) {
              html += `<div class="unsupported-category"><div class="unsupported-category-name">${cat}</div><ul class="unsupported-list">`;
              grouped[cat].forEach((i) => (html += `<li class="unsupported-item">${i.name}</li>`));
              html += `</ul></div>`;
            }
            html += `</div>`;
          }
          unsupportedItemsDiv.innerHTML = html;
        } else unsupportedItemsDiv.innerHTML = "";
      };

      copyBtn.onclick = () => {
        navigator.clipboard.writeText(newPrefsOutput.value).then(() => {
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = "Copy to Clipboard"), 2000);
        });
      };
      clearBtn.onclick = () => {
        prefsInput.value = "";
        showResults({}, []);
      };

      let lastInput = "";
      prefsInput.addEventListener("input", () => {
        const val = prefsInput.value;
        if (val === lastInput) return;
        lastInput = val;
        if (!val.trim()) return showResults({}, [], {});
        getMapping()
          .then((mapping) => {
            let oldPrefs;
            try {
              oldPrefs = JSON.parse(val);
            } catch (e) {
              showResults({}, [], {});
              newPrefsOutput.value = `Error parsing preferences: ${e.message}`;
              return;
            }
            const { newPrefs, unsupportedItems, themeBases } = migratePrefs(mapping, oldPrefs);
            showResults(newPrefs, unsupportedItems, themeBases);
          })
          .catch((e) => {
            showResults({}, [], {});
            newPrefsOutput.value = `Error loading mapping file: ${e}`;
          });
      });
      showResults({}, [], {});
    </script>

    <script src="https://unpkg.com/lucide@latest"></script>
    <script>
      lucide.createIcons();
    </script>
  </body>
</html>

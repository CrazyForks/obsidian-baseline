<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Style Settings Migration Tool for Baseline</title>
    <link rel="stylesheet" href="styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-38V3HD97K9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-38V3HD97K9");
    </script>
  </head>
  <body>
    <div class="title-container">
      <h1>Style Settings Migration Tool for Baseline</h1>
      <a href="https://github.com/aaaaalexis/obsidian-baseline">View Baseline on GitHub</a>
    </div>
    <div class="setting-container">
      <div class="setting">
        <div class="setting-sidebar">
          <div class="sidebar-section">
            <div class="sidebar-title">Community plugins</div>
            <div class="sidebar-link">Minimal Theme Settings</div>
            <div class="sidebar-link is-active">Style Settings</div>
          </div>
        </div>
        <div class="setting-content">
          <div class="setting-header">
            <div class="setting-search">
              <i data-lucide="search"></i>
              Search Style Settings...
            </div>
            <div class="setting-actions">
              <button>Import</button>
              <button>Export</button>
            </div>
          </div>
          <div class="setting-list">
            <div class="setting-item">
              <i data-lucide="chevron-right"></i>
              <div class="setting-item-name">Minimal</div>
              <div class="setting-item-actions"><i data-lucide="rotate-ccw"></i><i data-lucide="cloud-download"></i></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="panels-container">
      <p>Export your existing Minimal style settings, then paste here to migrate to Baseline-compatible settings.</p>

      <div class="input-panel">
        <textarea
          class="prefs-input"
          placeholder='{
  "minimal-style@@bg1@@light": "#FFFFFF",
  "minimal-style@@tabs-style": "tabs-modern"
}'
        ></textarea>
        <div class="panel-actions">
          <button class="clear-btn">Clear</button>
        </div>
      </div>
      <div class="output-panel">
        <textarea class="prefs-output" disabled readonly></textarea>
        <div class="panel-actions">
          <button class="copy-btn">Copy to Clipboard</button>
          <a class="download-link" href="#" download="baseline-style-settings.json"><button class="download-btn">Download</button></a>
        </div>
        <div class="conflict-container"></div>
        <div class="unsupported-container"></div>
      </div>
    </div>

    <script>
      // --- Concise Baseline Migration Script ---
      const $ = (s) => document.querySelector(s);
      const prefsInput = $(".prefs-input"),
        newPrefsOutput = $(".prefs-output"),
        copyBtn = $(".copy-btn"),
        downloadLink = $(".download-link"),
        unsupportedItemsDiv = $(".unsupported-container"),
        conflictItemsDiv = $(".conflict-container"),
        clearBtn = $(".clear-btn");

      let mappingCache;

      const getMapping = () =>
        mappingCache
          ? Promise.resolve(mappingCache)
          : fetch("mapping.json")
              .then((r) => (r.ok ? r.json() : Promise.reject(`Status: ${r.status}`)))
              .then((d) => (mappingCache = d));

      // Fix for ensuring all migrated keys use 'baseline-style' as the base
      const migratePrefs = (mapping, oldPrefs) => {
        const newPrefs = {},
          unsupported = [],
          conflicts = {};

        // Find all theme base names and their readable names
        const themeBases = {};
        for (const themeKey in mapping) {
          if (mapping[themeKey] && mapping[themeKey].__name) {
            themeBases[themeKey] = mapping[themeKey].__name;
          }
        }
        for (const k in oldPrefs) {
          if (!Object.hasOwnProperty.call(oldPrefs, k)) continue;
          const seg = k.split("@@");
          if (seg.length < 2) continue;
          // Detect theme base (e.g. minimal-style, things-style, sanctum-style, etc.)
          const base = seg[0];
          // Find theme key (e.g. minimal, things, sanctum)
          let themeKey = null;
          for (const t in themeBases) {
            if (base.startsWith(t)) {
              themeKey = t;
              break;
            }
          }
          if (!themeKey) continue;
          // Ensure all migrated keys use 'baseline-style' as the base
          const newBase = "baseline-style";
          const oldId = seg[1],
            extra = seg.slice(2),
            themeMapping = mapping[themeKey],
            rule = themeMapping[oldId],
            val = oldPrefs[k];
          if (!rule) {
            const newKey = [newBase, oldId, ...extra].join("@@");
            if (newPrefs[newKey] !== undefined) {
              if (!conflicts[newKey]) conflicts[newKey] = [newPrefs[newKey]];
              conflicts[newKey].push(val);
            } else {
              newPrefs[newKey] = val;
            }
            continue;
          }
          if (rule.unsupported) {
            unsupported.push({
              name: rule.name || `Key '${oldId}'`,
              category: rule.category || "General",
              oldValue: val,
              theme: themeKey,
            });
            continue;
          }
          let newVal = val,
            newKey = rule.newId || oldId;
          if (rule.valueMapping) {
            const vRule = rule.valueMapping[val];
            if (vRule === undefined) {
              if (rule.valueMapping.__fallback !== undefined) {
                newVal = rule.valueMapping.__fallback;
              } else {
                unsupported.push({
                  name: `Value '${val}' for setting '${oldId}'`,
                  category: rule.category || "Unsupported Options",
                  theme: themeKey,
                });
                continue;
              }
            } else if (vRule.unsupported) {
              unsupported.push({
                name: vRule.name || `Option '${val}'`,
                category: vRule.category || "General",
                theme: themeKey,
              });
              continue;
            } else {
              newVal = vRule;
            }
          }
          const finalKey = [newBase, newKey, ...extra].join("@@");
          if (newPrefs[finalKey] !== undefined) {
            if (!conflicts[finalKey]) conflicts[finalKey] = [newPrefs[finalKey]];
            conflicts[finalKey].push(newVal);
          } else {
            newPrefs[finalKey] = newVal;
          }
        }
        return { newPrefs, unsupportedItems: unsupported, themeBases, conflicts };
      };

      // Ensure boolean values are not wrapped in double quotes in the output
      const showResults = (prefs, unsupported, themeBases, conflicts) => {
        const str = Object.keys(prefs).length ? JSON.stringify(prefs, (key, value) => (typeof value === "boolean" ? value : value), 2) : "";
        newPrefsOutput.value = str;
        downloadLink.href = "data:text/json;charset=utf-8," + encodeURIComponent(str);
        if (unsupported.length) {
          let html = "<h2>Unsupported style settings</h2>";
          const groupedByTheme = {};
          unsupported.forEach((i) => {
            const theme = i.theme || "unknown";
            if (!groupedByTheme[theme]) groupedByTheme[theme] = [];
            groupedByTheme[theme].push(i);
          });
          for (const theme in groupedByTheme) {
            const readable = (themeBases && themeBases[theme]) || theme;
            html += `<div class="unsupported-theme"><div class="unsupported-theme-name">${readable}</div>`;
            const grouped = groupedByTheme[theme].reduce((a, i) => ((a[i.category] = a[i.category] || []).push(i), a), {});
            for (const cat in grouped) {
              html += `<div class="unsupported-category"><div class="unsupported-category-name">${cat}</div><ul class="unsupported-list">`;
              grouped[cat].forEach((i) => (html += `<li class="unsupported-item">${i.name}</li>`));
              html += `</ul></div>`;
            }
            html += `</div>`;
          }
          unsupportedItemsDiv.innerHTML = html;
        } else unsupportedItemsDiv.innerHTML = "";

        if (Object.keys(conflicts).length) {
          let conflictHtml = "<h2>Conflicts</h2>";
          for (const key in conflicts) {
            const strippedKey = key.replace(/^baseline-style@@/, "");
            const themeType = strippedKey.includes("@@light") ? "Light Theme" : strippedKey.includes("@@dark") ? "Dark Theme" : "";
            const displayKey = strippedKey.replace(/@@(light|dark)$/, "");

            conflictHtml += `<div class="conflict-item">`;
            conflictHtml += `<div class="conflict-key">${displayKey}</div>`;
            if (themeType) {
              conflictHtml += `<div class="conflict-theme">${themeType}</div>`;
            }
            conflictHtml += `<div class="conflict-actions">`;

            conflicts[key].forEach((val, idx) => {
              const isColor = /^#[0-9A-Fa-f]{6}$/.test(val); // Check if the value is a valid hex color
              conflictHtml += `<label data-conflict-key="${key}" data-conflict-value="${val}" class="conflict-label ${idx === 0 ? "selected" : ""}">${val}`;
              if (isColor) {
                conflictHtml += `<span class="color-preview" style="background-color: ${val};"></span>`;
              }
              conflictHtml += `</label>`;
            });
            conflictHtml += `</div></div>`;
          }
          conflictItemsDiv.innerHTML = conflictHtml;

          // Add event listeners for live updates
          document.querySelectorAll(".conflict-label").forEach((label) => {
            label.addEventListener("click", () => {
              const key = label.dataset.conflictKey;
              const value = label.dataset.conflictValue;

              // Update selected class
              document.querySelectorAll(`[data-conflict-key='${key}']`).forEach((l) => l.classList.remove("selected"));
              label.classList.add("selected");

              // Update preferences
              const selectedPrefs = { ...prefs };
              document.querySelectorAll(".conflict-label.selected").forEach((selectedLabel) => {
                const conflictKey = selectedLabel.dataset.conflictKey;
                const conflictValue = selectedLabel.dataset.conflictValue;
                selectedPrefs[conflictKey] = conflictValue === "true" ? true : conflictValue === "false" ? false : conflictValue;
              });
              newPrefsOutput.value = JSON.stringify(selectedPrefs, (key, value) => (typeof value === "boolean" ? value : value), 2);
              downloadLink.href = "data:text/json;charset=utf-8," + encodeURIComponent(newPrefsOutput.value);
            });
          });
        } else {
          conflictItemsDiv.innerHTML = "";
        }
      };

      copyBtn.onclick = () => {
        navigator.clipboard.writeText(newPrefsOutput.value).then(() => {
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = "Copy to Clipboard"), 2000);
        });
      };
      clearBtn.onclick = () => {
        prefsInput.value = "";
        showResults({}, []);
      };

      let lastInput = "";
      prefsInput.addEventListener("input", () => {
        const val = prefsInput.value;
        if (val === lastInput) return;
        lastInput = val;
        if (!val.trim()) return showResults({}, [], {}, {});
        getMapping()
          .then((mapping) => {
            let oldPrefs;
            try {
              oldPrefs = JSON.parse(val);
            } catch (e) {
              showResults({}, [], {}, {});
              newPrefsOutput.value = `Error parsing preferences: ${e.message}`;
              return;
            }
            const { newPrefs, unsupportedItems, themeBases, conflicts } = migratePrefs(mapping, oldPrefs);
            showResults(newPrefs, unsupportedItems, themeBases, conflicts);
          })
          .catch((e) => {
            showResults({}, [], {}, {});
            newPrefsOutput.value = `Error loading mapping file: ${e}`;
          });
      });
      showResults({}, [], {}, {});
    </script>

    <script>
      // Temporary script to fill input with predefined JSON
      const tempPrefs = {
        "minimal-style@@text-highlight-bg@@light": "#ffffff",
        "things-style@@text-highlight-bg-l": "#000000",
        "minimal-style@@text-highlight-bg@@dark": "#00ffff",
        "things-style@@text-highlight-bg-d": "#ff0000",
        "minimal-style@@active-line-on": true,
        "things-style@@active-line-on": false,
        "things-style@@link-decoration": true,
      };

      document.addEventListener("DOMContentLoaded", () => {
        const prefsInput = document.querySelector(".prefs-input");
        if (prefsInput) {
          prefsInput.value = JSON.stringify(tempPrefs, null, 2);
          // Trigger the input event to start the migration process
          prefsInput.dispatchEvent(new Event("input"));
        }
      });
    </script>

    <script src="https://unpkg.com/lucide@latest"></script>
    <script>
      lucide.createIcons();
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Style Settings Migration Tool for Baseline</title>
    <link rel="stylesheet" href="styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-38V3HD97K9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-38V3HD97K9");
    </script>
  </head>
  <body>
    <div class="title-container">
      <h1>Style Settings Migration Tool for Baseline</h1>
      <a href="https://github.com/aaaaalexis/obsidian-baseline">View Baseline on GitHub</a>
    </div>
    <div class="setting-container" title="Export your existing style settings, then paste here to migrate to Baseline-compatible settings.">
      <div class="setting">
        <div class="setting-sidebar">
          <div class="sidebar-section">
            <div class="sidebar-title">Community plugins</div>
            <div class="sidebar-link is-active">Style Settings</div>
          </div>
        </div>
        <div class="setting-content">
          <div class="setting-header">
            <div class="setting-search">
              <i data-lucide="search"></i>
              Search Style Settings...
            </div>
            <div class="setting-actions">
              <button>Import</button>
              <button>Export</button>
            </div>
          </div>
          <div class="setting-list">
            <div class="setting-item">
              <i data-lucide="chevron-right"></i>
              <div class="setting-item-name">Minimal</div>
              <div class="setting-item-actions"><i data-lucide="rotate-ccw"></i><i data-lucide="cloud-download"></i></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="panels-container">
      <p>Export your existing Minimal style settings, then paste here to migrate to Baseline-compatible settings.</p>

      <div class="input-panel">
        <textarea
          class="prefs-input"
          placeholder='{
  "minimal-style@@bg1@@light": "#FFFFFF",
  "minimal-style@@tabs-style": "tabs-modern"
}'
        ></textarea>
        <div class="panel-actions">
          <button class="clear-btn">Clear</button>
          <div class="supported-themes">Supports Minimal, AnuPpuccin, Border, Sanctum, Things 2</div>
        </div>
      </div>
      <div class="output-panel">
        <textarea class="prefs-output" disabled readonly></textarea>
        <div class="panel-actions">
          <button class="copy-btn">Copy to Clipboard</button>
          <a class="download-link" href="#" download="baseline-style-settings.json"><button class="download-btn">Download</button></a>
        </div>
        <div class="conflict-container"></div>
        <div class="unsupported-container"></div>
      </div>
    </div>

    <script>
      (() => {
        // DOM helpers
        const $ = (s) => document.querySelector(s);
        const prefsInput = $(".prefs-input");
        const newPrefsOutput = $(".prefs-output");
        const copyBtn = $(".copy-btn");
        const downloadLink = $(".download-link");
        const unsupportedDiv = $(".unsupported-container");
        const conflictDiv = $(".conflict-container");
        const clearBtn = $(".clear-btn");

        let mappingCache = null;

        async function getMapping() {
          if (mappingCache) return mappingCache;
          const res = await fetch("mapping.json");
          if (!res.ok) throw new Error(`Status: ${res.status}`);
          mappingCache = await res.json();
          return mappingCache;
        }

        function migratePrefs(mapping, oldPrefs) {
          const newPrefs = {},
            unsupported = [],
            conflicts = {},
            themeBases = {};
          for (const themeKey in mapping) {
            if (mapping[themeKey]?.__name) themeBases[themeKey] = mapping[themeKey].__name;
          }
          for (const k in oldPrefs) {
            if (!Object.hasOwnProperty.call(oldPrefs, k)) continue;
            const seg = k.split("@@");
            if (seg.length < 2) continue;
            const base = seg[0];
            let themeKey = Object.keys(themeBases).find((t) => base.startsWith(t));
            if (!themeKey) continue;
            const newBase = "baseline-style";
            const oldId = seg[1],
              extra = seg.slice(2);
            const themeMapping = mapping[themeKey];
            const rules = Array.isArray(themeMapping[oldId]) ? themeMapping[oldId] : [themeMapping[oldId]];
            const val = oldPrefs[k];
            if (!rules[0]) {
              const newKey = [newBase, oldId, ...extra].join("@@");
              if (newPrefs[newKey] !== undefined) {
                (conflicts[newKey] ??= [newPrefs[newKey]]).push(val);
              } else {
                newPrefs[newKey] = val;
              }
              continue;
            }
            for (const rule of rules) {
              if (!rule) continue;
              if (rule.unsupported) {
                unsupported.push({
                  name: rule.name || `Key '${oldId}'`,
                  category: rule.category || "General",
                  oldValue: val,
                  theme: themeKey,
                });
                continue;
              }
              let newVal = val,
                newKey = rule.newId || oldId;
              if (rule.valueMapping) {
                const vRule = rule.valueMapping[val];
                if (vRule === undefined) {
                  if (rule.valueMapping.__fallback !== undefined) {
                    newVal = rule.valueMapping.__fallback;
                  } else {
                    unsupported.push({
                      name: `Value '${val}' for setting '${oldId}'`,
                      category: rule.category || "Unsupported Options",
                      theme: themeKey,
                    });
                    continue;
                  }
                } else if (vRule.unsupported) {
                  unsupported.push({
                    name: vRule.name || `Option '${val}'`,
                    category: vRule.category || "General",
                    theme: themeKey,
                  });
                  continue;
                } else {
                  newVal = vRule;
                }
              }
              // Support multiple newIds as array
              if (Array.isArray(newKey)) {
                for (const nk of newKey) {
                  const finalKey = [newBase, nk, ...extra].join("@@");
                  if (newPrefs[finalKey] !== undefined) {
                    (conflicts[finalKey] ??= [newPrefs[finalKey]]).push(newVal);
                  } else {
                    newPrefs[finalKey] = newVal;
                  }
                }
              } else {
                const finalKey = [newBase, newKey, ...extra].join("@@");
                if (newPrefs[finalKey] !== undefined) {
                  (conflicts[finalKey] ??= [newPrefs[finalKey]]).push(newVal);
                } else {
                  newPrefs[finalKey] = newVal;
                }
              }
            }
          }
          // Remove conflicts where all values are identical
          for (const key in conflicts) {
            const vals = conflicts[key];
            if (vals.every((v) => v === vals[0])) {
              newPrefs[key] = vals[0];
              delete conflicts[key];
            }
          }
          // Deduplicate conflict values
          for (const key in conflicts) {
            const vals = conflicts[key];
            // Only keep unique values
            conflicts[key] = Array.from(new Set(vals));
          }
          return { newPrefs, unsupported, themeBases, conflicts };
        }

        function renderUnsupported(unsupported, themeBases) {
          if (!unsupported.length) return (unsupportedDiv.innerHTML = "");
          let html = `<h2>Unsupported style settings</h2>`;
          const byTheme = {};
          for (const i of unsupported) (byTheme[i.theme || "unknown"] ??= []).push(i);
          for (const theme in byTheme) {
            const readable = themeBases?.[theme] || theme;
            html += `<div class="unsupported-theme"><div class="unsupported-theme-name">${readable}</div>`;
            const byCat = {};
            for (const i of byTheme[theme]) (byCat[i.category] ??= []).push(i);
            for (const cat in byCat) {
              html += `<div class="unsupported-category"><div class="unsupported-category-name">${cat}</div><ul class="unsupported-list">`;
              for (const i of byCat[cat]) html += `<li class="unsupported-item">${i.name}</li>`;
              html += `</ul></div>`;
            }
            html += `</div>`;
          }
          unsupportedDiv.innerHTML = html;
        }

        async function getBaselineLabels() {
          if (getBaselineLabels.cache) return getBaselineLabels.cache;
          const res = await fetch("mapping-baseline.json");
          if (!res.ok) throw new Error(`Status: ${res.status}`);
          const labels = await res.json();
          getBaselineLabels.cache = labels;
          return labels;
        }

        async function renderConflicts(conflicts, prefs) {
          if (!Object.keys(conflicts).length) return (conflictDiv.innerHTML = "");
          let html = `<h2>Conflicts</h2>`;
          const labels = await getBaselineLabels().catch(() => ({}));
          for (const key in conflicts) {
            const strippedKey = key.replace(/^baseline-style@@/, "");
            // Use only the part before @@light/@@dark for label lookup
            const labelKey = strippedKey.replace(/@@(light|dark)$/, "");
            const themeType = strippedKey.includes("@@light") ? "Light Theme" : strippedKey.includes("@@dark") ? "Dark Theme" : "";
            // Use label from mapping-baseline.json if available
            const displayKey = labels[labelKey] || labelKey;
            html += `<div class="conflict-item"><div class="conflict-key">${displayKey}</div>`;
            if (themeType) html += `<div class="conflict-theme">${themeType}</div>`;
            html += `<div class="conflict-actions">`;
            conflicts[key].forEach((val, idx) => {
              // Try to get a label for the value if available
              let valueLabel = val;
              // If labels for values are present, use them (optional, fallback to value)
              if (labels && labels[val]) valueLabel = labels[val];
              const isColor = /^#[0-9A-Fa-f]{6}$/.test(val);
              html += `<label data-conflict-key="${key}" data-conflict-value="${val}" class="conflict-label${idx === 0 ? " selected" : ""}">${valueLabel}`;
              if (isColor) html += `<span class="color-preview" style="background-color: ${val};"></span>`;
              html += `</label>`;
            });
            html += `</div></div>`;
          }
          conflictDiv.innerHTML = html;
          // Add listeners for conflict selection
          conflictDiv.querySelectorAll(".conflict-label").forEach((label) => {
            label.onclick = () => {
              const key = label.dataset.conflictKey;
              conflictDiv.querySelectorAll(`[data-conflict-key='${key}']`).forEach((l) => l.classList.remove("selected"));
              label.classList.add("selected");
              // Update output with selected values
              const selectedPrefs = { ...prefs };
              conflictDiv.querySelectorAll(".conflict-label.selected").forEach((sel) => {
                const k = sel.dataset.conflictKey;
                let v = sel.dataset.conflictValue;
                if (v === "true") v = true;
                else if (v === "false") v = false;
                selectedPrefs[k] = v;
              });
              updateOutput(selectedPrefs);
            };
          });
        }

        function updateOutput(prefs) {
          const str = Object.keys(prefs).length ? JSON.stringify(prefs, (k, v) => (typeof v === "boolean" ? v : v), 2) : "";
          newPrefsOutput.value = str;
          downloadLink.href = "data:text/json;charset=utf-8," + encodeURIComponent(str);
        }

        async function showResults(prefs, unsupported, themeBases, conflicts) {
          updateOutput(prefs);
          renderUnsupported(unsupported, themeBases);
          await renderConflicts(conflicts, prefs);
        }

        copyBtn.onclick = () => {
          navigator.clipboard.writeText(newPrefsOutput.value).then(() => {
            copyBtn.textContent = "Copied!";
            setTimeout(() => (copyBtn.textContent = "Copy to Clipboard"), 2000);
          });
        };
        clearBtn.onclick = () => {
          prefsInput.value = "";
          showResults({}, [], {}, {});
        };

        let lastInput = "";
        prefsInput.addEventListener("input", () => {
          const val = prefsInput.value;
          if (val === lastInput) return;
          lastInput = val;
          if (!val.trim()) return showResults({}, [], {}, {});
          getMapping()
            .then((mapping) => {
              let oldPrefs;
              try {
                oldPrefs = JSON.parse(val);
              } catch (e) {
                showResults({}, [], {}, {});
                newPrefsOutput.value = `Error parsing preferences: ${e.message}`;
                return;
              }
              const { newPrefs, unsupported, themeBases, conflicts } = migratePrefs(mapping, oldPrefs);
              showResults(newPrefs, unsupported, themeBases, conflicts);
            })
            .catch((e) => {
              showResults({}, [], {}, {});
              newPrefsOutput.value = `Error loading mapping file: ${e.message || e}`;
            });
        });
        showResults({}, [], {}, {});
      })();
    </script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script>
      lucide.createIcons();
    </script>
  </body>
</html>
